const validateRow = (row, index) => {
    const rowNumber = index + 2;
    const rowErrors = [];

    const sanitize = (val) => (val ? String(val).trim() : "");

    const {
      UCN,
      "Firm Registration No.": frnRaw,
      "Firm Name": firmNameRaw,
      "PAN NO.": panRaw,
      "GSTIN NO.": gstinRaw,
      "Address Line": addressRaw,
      City: cityRaw,
      "State Name": stateRaw,
      "District Name": districtRaw,
      "Pin Code": pinRaw,
      "Primary Mobile No.": mobileRaw,
      "Point of Contact": contactNameRaw,
      "Point of Contact's Designation": contactDesigRaw,
      "Point of Contact Email": contactEmailRaw,
      "Type of Establishment": establishmentRaw,
    } = row;

    // Clean all fields once
    const ucn = sanitize(UCN);
    const frn = sanitize(frnRaw);
    const firmName = sanitize(firmNameRaw);
    const pan = sanitize(panRaw);
    const gstin = sanitize(gstinRaw);
    const address = sanitize(addressRaw);
    const city = sanitize(cityRaw);
    const state = sanitize(stateRaw);
    const district = sanitize(districtRaw);
    const pin = sanitize(pinRaw);
    const mobile = sanitize(mobileRaw);
    const contactName = sanitize(contactNameRaw);
    const contactDesig = sanitize(contactDesigRaw);
    const contactEmail = sanitize(contactEmailRaw);
    const establishment = sanitize(establishmentRaw).toLowerCase();

    if (ucn && !isOnlyNumbers(ucn))
      rowErrors.push("UCN must contain numbers only.");

    if (!isValidFrn(frn))
      rowErrors.push(
        "Firm Registration No. must be alphanumeric (allowing '/')"
      );

    if (!firmName) rowErrors.push("Firm Name is required");

    if (pan && !isPAN(pan)) rowErrors.push("Invalid PAN (alphanumeric only)");

    if (gstin && !isGSTIN(gstin))
      rowErrors.push("Invalid GSTIN (alphanumeric only)");

    if (!isAddress(address) || address.length > 250)
      rowErrors.push(
        "Address must contain only alphabets and whitelisted chars[:;=(),.:/-_&]." +
          " Address must not be greater than 250 characters."
      );

    if (!isAlphanumeric(city))
      rowErrors.push("City must contain only alphabets");
    if (!isState(state)) rowErrors.push("State must contain only alphabets");
    if (!isAlphanumeric(district))
      rowErrors.push("District must contain only alphabets");

    if (!isPinCode(pin)) rowErrors.push("Pin Code must be 6 digits");

    if (!isMobile(mobile)) rowErrors.push("Mobile number must be 10 digits");

    if (!isAlpha(contactName))
      rowErrors.push("Contact Name must contain only text");

    if (!isAlpha(contactDesig))
      rowErrors.push("Designation must contain only text");
    if (contactDesig.length > 20)
      rowErrors.push("Designation must not be greater than 20 characters. ");
    if (!contactEmail) rowErrors.push("Contact Email is required");

    const validEstablishments = [
      "partnership firm",
      "proprietorship firm",
      "partnership",
      "proprietorship",
      "other",
    ];
    if (!validEstablishments.includes(establishment.toLowerCase()))
      rowErrors.push("Invalid Type of Establishment");

    return {
      rowNumber,
      isValid: rowErrors.length === 0,
      errors: rowErrors,
    };
  };



const handleExcelUpload = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const MAX_SIZE_MB = 5;
    const maxSizeBytes = MAX_SIZE_MB * 1024 * 1024;

    if (file.size > maxSizeBytes) {
      showSnackbar(
        `File size exceed: File size should not exceed more than ${MAX_SIZE_MB} MB`,
        "error"
      );
      e.target.value = null;
      return;
    }

    try {
      setLoading(true);
      const reader = new FileReader();

      reader.onload = async (evt) => {
        try {
          const excelData = new Uint8Array(evt.target.result);
          const workbook = XLSX.read(excelData, { type: "array" });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];

          //  Read full data with headers preserved (even empty ones)
          const sheetData = XLSX.utils.sheet_to_json(sheet, {
            header: 1,
            defval: "", // ensures empty cells become empty string instead of undefined
          });

          //  Extract headers from first row
          const actualHeaders = sheetData[0] || [];
          // console.log("Excel Headers:", actualHeaders);

          //  Header validation
          const missingHeaders = REQUIRED_HEADERS.filter(
            (header) => !actualHeaders.includes(header)
          );

          if (missingHeaders.length > 0) {
            showSnackbar(
              `Invalid Excel Format. Missing headers: ${missingHeaders.join(
                ", "
              )}`,
              "error"
            );
            
            setChildData({ columns: [], rows: [] });
            e.target.value = null;
            return;
          }

          //  Convert remaining rows into objects (preserve all columns)
          const rows = sheetData.slice(1).map((rowArr) => {
            const rowObj = {};
            actualHeaders.forEach((header, i) => {
              rowObj[header] = rowArr[i] ?? "";
            });
            return rowObj;
          });

          //  Validate each row
          const errors = [];
          const validRows = [];

          rows.forEach((row, index) => {
            const {
              rowNumber,
              isValid,
              errors: rowErrors,
            } = validateRow(row, index);

            if (isValid) {
              validRows.push(row);
            } else {
              errors.push({ row: rowNumber, issues: rowErrors });
            }
          });

          //  Handle validation errors
          if (errors.length > 0) {
            console.error("Validation Errors", errors);
            showSnackbar(
              `${errors.length} row(s) have issues. Downloading Excel...`,
              "error"
            );
            exportInvalidRows(errors, rows);
            setLoading(false);
            //return;
          } else {
            showSnackbar("All rows validated successfully!", "success");
          }

          //  Rename keys if required (your custom function)
          const renamedRows = renameKeys(validRows);

          //  API call
          const { data, error } = await apiCaller(
            "POST",
            "/Server/empanelment/uploadExcelData",
            { firms: renamedRows }
          );

          if (error || !data?.result?.result) {
            // setErrorMessage(data?.message || "FRN not found");
            showSnackbar(data?.message || "FRN not found", "error");
            // setChildData({ columns: [], rows: [] });
          } else if (data.result?.FailedData.length > 0) {
            showSnackbar(
              data.result?.FailedData.length +
                " firms are already empanelled. " +
                data.result?.SuccessCount.length +
                " request/s sent to checker for approval.",
              "warning"
            );
          } else {
            // Do not update table preview
            showSnackbar(
              validRows.length + " request/s sent to checker for approval.",
              "warning"
            );
          }
        } catch (err) {
          console.error("Error parsing Excel:", err);
          showSnackbar("Error parsing Excel file.", "error");
          // setChildData({ columns: [], rows: [] });
        } finally {
          setLoading(false);
          e.target.value = null;
        }
      };

      reader.readAsArrayBuffer(file);
    } catch (err) {
      console.error("Unexpected error:", err);
      showSnackbar("An error occurred while processing the file.", "error");
      setChildData({ columns: [], rows: [] });
      setLoading(false);
      e.target.value = null;
    }
  };




