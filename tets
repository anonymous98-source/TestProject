package com.fincore.gateway.Service;

import com.fincore.gateway.dto.MenuResponse;
import com.fincore.gateway.dto.UpdatePasswordDTO;
import com.fincore.gateway.dto.UserDto;
import com.fincore.gateway.dto.VerifyUserDTO;
import com.fincore.gateway.model.LoginAttempt;
import com.fincore.gateway.model.LoginParam;
import com.fincore.gateway.model.User;

import org.springframework.stereotype.Service;

@Service
public interface LoginService {

    UserDto verifyUserCredentials(UserDto userCredentials,String clientIp);

    MenuResponse fetchRoleWiseData(String userId);

    VerifyUserDTO checkUser(String userId);

    UpdatePasswordDTO updatePassword(UpdatePasswordDTO userCredentials);

    void passwordBasedLogin(String password, LoginAttempt loginAttempt, UserDto userInfo, User user, LoginParam loginparam);

    String generateStatusMessage(String status,String type);
}


package com.fincore.gateway.Service;

import com.fincore.gateway.dto.*;
import com.fincore.gateway.model.Permissions;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
public class MenuService {

    public MenuResponse transform(List<Permissions> permissionsList) {
        MenuResponse response = new MenuResponse();

        // Group by root menuTitle
        Map<String, List<Permissions>> grouped = permissionsList.stream()
                .collect(Collectors.groupingBy(Permissions::getMenuTitle));

        List<RootMenu> rootMenus = new ArrayList<>();

        for (Map.Entry<String, List<Permissions>> entry : grouped.entrySet()) {
            List<Permissions> group = entry.getValue();
            Permissions rootPerm = group.get(0);

            RootMenu rootMenu = new RootMenu();
            rootMenu.setId(rootPerm.getMenuId());
            rootMenu.setTitle(rootPerm.getMenuTitle());
            rootMenu.setIcon(rootPerm.getMenuIcon());
            rootMenu.setRoute(rootPerm.getMenuUrl());
            rootMenu.setComponentPath(rootPerm.getComponentPath());
            rootMenu.setScreenDescription(rootPerm.getMenuDescription());
            rootMenu.setOrderId(rootPerm.getOrderId());

            if (group.size() > 1) {
                rootMenu.setHasChildren(true);

                // ✅ Sort children by orderId in ascending order
                List<ChildMenu> children = group.stream()
                        .filter(p -> p.getSubMenu() != null)
                        .map(MenuService::getChildMenu)
                        .sorted(Comparator.comparingInt(ChildMenu::getOrderId)) // ascending order
                        .collect(Collectors.toList());

                rootMenu.setChildren(children);
            } else {
                rootMenu.setHasChildren(false);
            }

            rootMenus.add(rootMenu);
        }

        // ✅ (Optional) Also sort root menus by orderId if needed
        rootMenus.sort(Comparator.comparingInt(RootMenu::getOrderId));

        response.setRoot_menus(rootMenus);
        return response;
    }

    
    public MenuResponse transformFromProjection(List<PermissionRow> rows) {
        MenuResponse response = new MenuResponse();

        // group by root menu title
        Map<String, List<PermissionRow>> grouped = rows.stream()
                .collect(Collectors.groupingBy(PermissionRow::getMenuTitle));

        List<RootMenu> rootMenus = new ArrayList<>();

        for (Map.Entry<String, List<PermissionRow>> entry : grouped.entrySet()) {
            List<PermissionRow> group = entry.getValue();
            PermissionRow root = group.get(0);

            RootMenu rootMenu = new RootMenu();
            rootMenu.setId(root.getMenuId());
            rootMenu.setTitle(root.getMenuTitle());
            rootMenu.setIcon(root.getMenuIcon());
            rootMenu.setRoute(root.getMenuUrl());
            rootMenu.setComponentPath(root.getComponentPath());
            rootMenu.setScreenDescription(root.getMenuDescription());
            // if you also want root items ordered, you can set this from first row
            rootMenu.setOrderId(root.getPermissionOrder());

            // children (sorted by permissionOrder asc)
            List<ChildMenu> children = group.stream()
                    .filter(r -> r.getSubMenu() != null)
                    .map(r -> {
                        ChildMenu c = new ChildMenu();
                        c.setId(r.getMenuId());
                        c.setTitle(r.getSubMenu());
                        c.setIcon(r.getMenuIcon());
                        c.setRoute(r.getMenuUrl());
                        c.setComponentPath(r.getComponentPath());
                        c.setScreenDescription(r.getMenuDescription());
                        c.setOrderId(r.getPermissionOrder()); // comes from rp
                        return c;
                    })
                    .sorted(Comparator.comparingInt(ChildMenu::getOrderId))
                    .collect(Collectors.toList());

            rootMenu.setHasChildren(!children.isEmpty());
            rootMenu.setChildren(children);
            rootMenus.add(rootMenu);
        }

        // optional: order root menus as well
        rootMenus.sort(Comparator.comparingInt(RootMenu::getOrderId));

        response.setRoot_menus(rootMenus);
        return response;
    }
    
    @NotNull
    private static ChildMenu getChildMenu(Permissions p) {
        ChildMenu child = new ChildMenu();
        child.setId(p.getMenuId());
        child.setTitle(p.getSubMenu());
        child.setIcon(p.getMenuIcon());
        child.setRoute(p.getMenuUrl());
        child.setComponentPath(p.getComponentPath());
        child.setScreenDescription(p.getMenuDescription());
        child.setOrderId(p.getOrderId());
        return child;
    }
}
