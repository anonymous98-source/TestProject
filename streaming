Perfect ‚Äî this is a structural enhancement, not just UI polish.
We‚Äôll do it properly, with clean domain modeling and minimal but correct class changes.


---

üéØ REQUIREMENT CLARIFIED

You want:

Groups

EXPENSES

Necessary Expenses

EMIs

Miscellaneous

(any user-added expense category)


SAVINGS / INVESTMENTS

Emergency Fund

Health Emergency

Savings

Investments

(any user-added saving category)



Outputs

1. Category-level table (already exists)


2. Group-level summary table:

Group        | Total % | Total Amount
--------------------------------------
Expenses     | 70%     | ‚Çπ70,000
Savings      | 30%     | ‚Çπ30,000


3. Pie chart based on GROUPS (Expenses vs Savings)
(not individual categories)




---

üß† DESIGN (IMPORTANT ‚Äì WHY THIS IS CORRECT)

Key decisions

Grouping is domain logic, not UI logic

Category knows its GroupType

Service calculates group aggregates

Pie chart uses group data

Tables stay independent



---

1Ô∏è‚É£ NEW ENUM ‚Äì GroupType

GroupType.java (NEW)

package com.fundsmanager.model;

public enum GroupType {
    EXPENSE("Expenses"),
    SAVING("Savings");

    private final String displayName;

    GroupType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}


---

2Ô∏è‚É£ Category MODEL (CHANGED)

Category.java (FULL UPDATED CODE)

package com.fundsmanager.model;

public class Category {

    private String name;
    private double percentage;
    private boolean locked;
    private GroupType groupType; // üî• NEW

    public Category(String name, double percentage, boolean locked, GroupType groupType) {
        this.name = name;
        this.percentage = percentage;
        this.locked = locked;
        this.groupType = groupType;
    }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public double getPercentage() { return percentage; }
    public void setPercentage(double percentage) { this.percentage = percentage; }

    public boolean isLocked() { return locked; }

    public GroupType getGroupType() { return groupType; }
    public void setGroupType(GroupType groupType) { this.groupType = groupType; }
}


---

3Ô∏è‚É£ DefaultCategories (CHANGED)

DefaultCategories.java

package com.fundsmanager.util;

import com.fundsmanager.model.Category;
import com.fundsmanager.model.GroupType;

import java.util.List;

public class DefaultCategories {

    public static List<Category> load() {
        return List.of(
            new Category("Necessary Expenses", 40, true, GroupType.EXPENSE),
            new Category("Emergency Fund", 10, true, GroupType.SAVING),
            new Category("Health Emergency", 10, true, GroupType.SAVING),
            new Category("EMIs", 15, true, GroupType.EXPENSE),
            new Category("Savings", 10, false, GroupType.SAVING),
            new Category("Investments", 10, false, GroupType.SAVING),
            new Category("Miscellaneous", 5, false, GroupType.EXPENSE)
        );
    }
}


---

4Ô∏è‚É£ NEW DTO ‚Äì GroupSummary

GroupSummary.java (NEW)

package com.fundsmanager.model;

public class GroupSummary {

    private final GroupType groupType;
    private final double totalPercentage;
    private final double totalAmount;

    public GroupSummary(GroupType groupType, double totalPercentage, double totalAmount) {
        this.groupType = groupType;
        this.totalPercentage = totalPercentage;
        this.totalAmount = totalAmount;
    }

    public GroupType getGroupType() { return groupType; }
    public double getTotalPercentage() { return totalPercentage; }
    public double getTotalAmount() { return totalAmount; }
}


---

5Ô∏è‚É£ FundCalculationService (CHANGED ‚Äì CORE LOGIC)

FundCalculationService.java (FULL UPDATED)

package com.fundsmanager.service;

import com.fundsmanager.model.*;

import java.util.*;
import java.util.stream.Collectors;

public class FundCalculationService {

    public List<FundAllocation> calculate(double income, List<Category> categories) {

        List<FundAllocation> result = new ArrayList<>();

        for (Category c : categories) {
            double amount = income * c.getPercentage() / 100;
            result.add(new FundAllocation(
                    c.getName(),
                    c.getPercentage(),
                    amount
            ));
        }
        return result;
    }

    public List<GroupSummary> calculateGroupSummary(
            double income,
            List<Category> categories
    ) {

        Map<GroupType, Double> percentMap = new EnumMap<>(GroupType.class);
        Map<GroupType, Double> amountMap = new EnumMap<>(GroupType.class);

        for (GroupType gt : GroupType.values()) {
            percentMap.put(gt, 0.0);
            amountMap.put(gt, 0.0);
        }

        for (Category c : categories) {
            double percent = c.getPercentage();
            double amount = income * percent / 100;

            percentMap.put(
                    c.getGroupType(),
                    percentMap.get(c.getGroupType()) + percent
            );

            amountMap.put(
                    c.getGroupType(),
                    amountMap.get(c.getGroupType()) + amount
            );
        }

        List<GroupSummary> result = new ArrayList<>();
        for (GroupType gt : GroupType.values()) {
            result.add(new GroupSummary(
                    gt,
                    round(percentMap.get(gt)),
                    round(amountMap.get(gt))
            ));
        }

        return result;
    }

    public boolean validatePercentage(List<Category> categories) {
        double sum = categories.stream()
                .mapToDouble(Category::getPercentage)
                .sum();
        return Math.abs(sum - 100.0) < 0.01;
    }

    private double round(double v) {
        return Math.round(v * 100.0) / 100.0;
    }
}


---

6Ô∏è‚É£ NEW TABLE MODEL ‚Äì Group Summary Table

GroupSummaryTableModel.java (NEW)

package com.fundsmanager.ui;

import com.fundsmanager.model.GroupSummary;

import javax.swing.table.AbstractTableModel;
import java.util.List;

public class GroupSummaryTableModel extends AbstractTableModel {

    private final String[] columns = {
            "Group",
            "Total Percentage (%)",
            "Total Amount"
    };

    private List<GroupSummary> data;

    public void setData(List<GroupSummary> data) {
        this.data = data;
        fireTableDataChanged();
    }

    @Override
    public int getRowCount() {
        return data == null ? 0 : data.size();
    }

    @Override
    public int getColumnCount() {
        return columns.length;
    }

    @Override
    public String getColumnName(int col) {
        return columns[col];
    }

    @Override
    public Object getValueAt(int row, int col) {
        GroupSummary g = data.get(row);
        return switch (col) {
            case 0 -> g.getGroupType().getDisplayName();
            case 1 -> g.getTotalPercentage();
            default -> "‚Çπ " + String.format("%.2f", g.getTotalAmount());
        };
    }
}


---

7Ô∏è‚É£ PIE CHART ‚Äì GROUP-BASED (FULL UPDATED CODE)

PieChartPanel.java (FULL REPLACEMENT)

package com.fundsmanager.ui;

import com.fundsmanager.model.GroupSummary;
import com.fundsmanager.model.GroupType;
import org.jfree.chart.*;
import org.jfree.chart.plot.PiePlot;
import org.jfree.data.general.DefaultPieDataset;

import javax.swing.*;
import java.awt.*;
import java.util.List;

public class PieChartPanel extends JPanel {

    private JPanel chartHolder;

    public PieChartPanel() {
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createTitledBorder("Expenses vs Savings"));

        chartHolder = new JPanel(new BorderLayout());
        chartHolder.setPreferredSize(new Dimension(420, 280));

        JScrollPane scrollPane = new JScrollPane(chartHolder);
        scrollPane.setHorizontalScrollBarPolicy(
                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER
        );

        add(scrollPane, BorderLayout.CENTER);
    }

    public void updateChart(List<GroupSummary> summaries) {
        chartHolder.removeAll();

        DefaultPieDataset dataset = new DefaultPieDataset();
        for (GroupSummary gs : summaries) {
            dataset.setValue(
                    gs.getGroupType().getDisplayName(),
                    gs.getTotalAmount()
            );
        }

        JFreeChart chart = ChartFactory.createPieChart(
                "Overall Distribution",
                dataset,
                true,
                true,
                false
        );

        PiePlot plot = (PiePlot) chart.getPlot();

        plot.setSectionPaint(
                GroupType.EXPENSE.getDisplayName(),
                new Color(220, 53, 69)
        );

        plot.setSectionPaint(
                GroupType.SAVING.getDisplayName(),
                new Color(40, 167, 69)
        );

        ChartPanel cp = new ChartPanel(chart);
        cp.setPreferredSize(new Dimension(420, 260));

        chartHolder.add(cp, BorderLayout.CENTER);
        revalidate();
        repaint();
    }

    public void clear() {
        chartHolder.removeAll();
        repaint();
    }
}


---

8Ô∏è‚É£ HOW YOU USE THIS IN MainFrame

Inside generateReport():

List<GroupSummary> groupSummaries =
        service.calculateGroupSummary(
                income,
                categoryTableModel.getCategories()
        );

groupSummaryTableModel.setData(groupSummaries);
pieChartPanel.updateChart(groupSummaries);

And add a JTable for GroupSummaryTableModel below category report.


---

üèÜ FINAL RESULT

‚úÖ Categories still editable individually
‚úÖ Expenses vs Savings aggregated correctly
‚úÖ Group totals shown in table
‚úÖ Group totals shown in pie chart
‚úÖ Domain-driven, extensible design
‚úÖ Easy to add more groups later

This is exactly how real finance systems do aggregation.


---

If you want next:

Drill-down on pie slice click

More groups (Needs / Wants / Investments)

Group-wise budget warnings

Persist group config


Just tell me üëç