Got it ‚Äî you want for BOTH Normal and NIO:

‚úÖ Streaming start time
‚úÖ Streaming end time
‚úÖ Total time taken
‚úÖ Still:

runs in parallel

shows live single-line progress (IntelliJ-safe)

creates output directory if missing


Here is the FULL UPDATED WORKING CODE for IntelliJ 2025.x.


---

‚úÖ FULL CODE (with start time, end time, total time for both)

import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.*;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

public class StreamingWithTime {

    static AtomicLong normalCopied = new AtomicLong(0);
    static AtomicLong nioCopied = new AtomicLong(0);

    static long totalSize;

    static Instant normalStart, normalEnd;
    static Instant nioStart, nioEnd;

    static DateTimeFormatter formatter =
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    public static void main(String[] args) throws Exception {

        Path source = Paths.get("D:/bigfile.bin");

        // OUTPUT DIRECTORY (auto-create)
        Path outputDir = Paths.get("E:/output");
        Files.createDirectories(outputDir);

        Path normalDest = outputDir.resolve("bigfile_normal.bin");
        Path nioDest = outputDir.resolve("bigfile_nio.bin");

        totalSize = Files.size(source);

        ExecutorService executor = Executors.newFixedThreadPool(2);

        Instant overallStart = Instant.now();

        CompletableFuture<Void> normalFuture =
                CompletableFuture.runAsync(
                        new CopyTask(source, normalDest, normalCopied, true),
                        executor
                );

        CompletableFuture<Void> nioFuture =
                CompletableFuture.runAsync(
                        new CopyTask(source, nioDest, nioCopied, false),
                        executor
                );

        // Progress loop (IntelliJ-safe)
        while (!normalFuture.isDone() || !nioFuture.isDone()) {
            printSingleLineProgress(overallStart);
            Thread.sleep(1000);
        }

        // Final progress update
        printSingleLineProgress(overallStart);
        System.out.println("\n");

        executor.shutdown();

        // ===== PRINT FINAL TIME DETAILS =====
        System.out.println("========= NORMAL STREAMING =========");
        printTimeDetails("NORMAL", normalStart, normalEnd);

        System.out.println("\n========= NIO STREAMING =========");
        printTimeDetails("NIO", nioStart, nioEnd);
    }

    private static void printSingleLineProgress(Instant overallStart) {

        double normalPercent = (normalCopied.get() * 100.0) / totalSize;
        double nioPercent = (nioCopied.get() * 100.0) / totalSize;

        Duration elapsed = Duration.between(overallStart, Instant.now());
        double seconds = Math.max(1, elapsed.toMillis() / 1000.0);

        double normalSpeed =
                (normalCopied.get() / 1024.0 / 1024.0) / seconds;
        double nioSpeed =
                (nioCopied.get() / 1024.0 / 1024.0) / seconds;

        System.out.printf(
                "\rNORMAL: %6.2f%% | %6.2f MB/s  ||  NIO: %6.2f%% | %6.2f MB/s",
                normalPercent, normalSpeed,
                nioPercent, nioSpeed
        );

        System.out.flush();
    }

    private static void printTimeDetails(String name, Instant start, Instant end) {

        LocalDateTime startTime =
                LocalDateTime.ofInstant(start, java.time.ZoneId.systemDefault());
        LocalDateTime endTime =
                LocalDateTime.ofInstant(end, java.time.ZoneId.systemDefault());

        Duration duration = Duration.between(start, end);

        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long seconds = duration.toSecondsPart();

        System.out.println("Start Time : " + startTime.format(formatter));
        System.out.println("End Time   : " + endTime.format(formatter));
        System.out.println("Total Time : " + hours + " hours "
                + minutes + " minutes "
                + seconds + " seconds");
    }

    // ===================== COPY TASK =====================
    static class CopyTask implements Runnable {

        private final Path source;
        private final Path destination;
        private final AtomicLong progress;
        private final boolean isNormal;

        private static final int BUFFER_SIZE = 1024 * 1024; // 1 MB

        CopyTask(Path source, Path destination,
                 AtomicLong progress, boolean isNormal) {
            this.source = source;
            this.destination = destination;
            this.progress = progress;
            this.isNormal = isNormal;
        }

        @Override
        public void run() {
            try {
                if (isNormal) {
                    normalStart = Instant.now();
                } else {
                    nioStart = Instant.now();
                }

                Files.createDirectories(destination.getParent());

                try (FileChannel in = FileChannel.open(source, StandardOpenOption.READ);
                     FileChannel out = FileChannel.open(
                             destination,
                             StandardOpenOption.CREATE,
                             StandardOpenOption.WRITE,
                             StandardOpenOption.TRUNCATE_EXISTING)) {

                    ByteBuffer buffer = ByteBuffer.allocateDirect(BUFFER_SIZE);
                    int read;

                    while ((read = in.read(buffer)) != -1) {
                        buffer.flip();
                        out.write(buffer);
                        buffer.clear();

                        progress.addAndGet(read);
                    }
                }

                if (isNormal) {
                    normalEnd = Instant.now();
                } else {
                    nioEnd = Instant.now();
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}


---

üñ•Ô∏è Sample Final Output

NORMAL: 100.00% | 110.23 MB/s  ||  NIO: 100.00% | 108.45 MB/s

========= NORMAL STREAMING =========
Start Time : 2026-01-31 18:42:10
End Time   : 2026-01-31 18:44:05
Total Time : 0 hours 1 minutes 55 seconds

========= NIO STREAMING =========
Start Time : 2026-01-31 18:42:10
End Time   : 2026-01-31 18:43:52
Total Time : 0 hours 1 minutes 42 seconds


---

üéØ What you now have

‚úî Parallel streaming
‚úî IntelliJ-safe live progress
‚úî Start time per method
‚úî End time per method
‚úî Total duration per method
‚úî Auto-create output directory


---

If you want next upgrades, I can add:

‚úÖ Cancel button
‚úÖ Resume copy
‚úÖ SHA-256 checksum
‚úÖ Swing progress bars
‚úÖ REST API monitor

Just say which one: cancel / resume / checksum / swing / rest