Haha alright ‚Äî you asked for ALL üòé
Here is the full production-style solution with:

‚úÖ Parallel copy
‚úÖ Progress (%)
‚úÖ Speed (MB/sec)
‚úÖ Cancel support
‚úÖ CompletableFuture
‚úÖ NIO streaming
‚úÖ Clean shutdown


---

‚úÖ FULL WORKING CODE

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.*;
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

public class StreamingAdvanced {

    static AtomicBoolean cancelFlag = new AtomicBoolean(false);

    public static void main(String[] args) throws Exception {

        ExecutorService executor = Executors.newFixedThreadPool(2);

        CompletableFuture<Void> normalCopy =
                CompletableFuture.runAsync(
                        new CopyTask(
                                Paths.get("D:/bigfile.bin"),
                                Paths.get("E:/bigfile_normal.bin"),
                                "NORMAL"),
                        executor
                );

        CompletableFuture<Void> nioCopy =
                CompletableFuture.runAsync(
                        new CopyTask(
                                Paths.get("D:/bigfile.bin"),
                                Paths.get("E:/bigfile_nio.bin"),
                                "NIO"),
                        executor
                );

        // Simulate cancel after 10 seconds (optional)
        Thread.sleep(10000);
        cancelFlag.set(true);
        System.out.println("\n‚ùå Cancel requested!");

        CompletableFuture.allOf(normalCopy, nioCopy).join();
        executor.shutdown();

        System.out.println("\n‚úÖ Program finished.");
    }

    static class CopyTask implements Runnable {

        private final Path source;
        private final Path destination;
        private final String name;
        private static final int BUFFER_SIZE = 1024 * 1024; // 1MB

        CopyTask(Path source, Path destination, String name) {
            this.source = source;
            this.destination = destination;
            this.name = name;
        }

        @Override
        public void run() {
            try (FileChannel in = FileChannel.open(source, StandardOpenOption.READ);
                 FileChannel out = FileChannel.open(destination,
                         StandardOpenOption.CREATE,
                         StandardOpenOption.WRITE,
                         StandardOpenOption.TRUNCATE_EXISTING)) {

                long totalSize = in.size();
                long copied = 0;

                ByteBuffer buffer = ByteBuffer.allocateDirect(BUFFER_SIZE);

                Instant start = Instant.now();

                while (copied < totalSize) {

                    if (cancelFlag.get()) {
                        System.out.println(name + " ‚ùå cancelled at " + percent(copied, totalSize) + "%");
                        return;
                    }

                    buffer.clear();
                    int read = in.read(buffer);
                    if (read == -1) break;

                    buffer.flip();
                    out.write(buffer);

                    copied += read;

                    printProgress(copied, totalSize, start);
                }

                System.out.println("\n" + name + " ‚úÖ completed successfully.");

            } catch (Exception e) {
                System.out.println(name + " ‚ùå failed: " + e.getMessage());
            }
        }

        private void printProgress(long copied, long total, Instant start) {
            double percent = percent(copied, total);

            Duration elapsed = Duration.between(start, Instant.now());
            double seconds = Math.max(1, elapsed.toMillis() / 1000.0);
            double speed = (copied / 1024.0 / 1024.0) / seconds;

            System.out.printf("\r%s Progress: %.2f%% | Speed: %.2f MB/s",
                    name, percent, speed);
        }

        private double percent(long copied, long total) {
            return (copied * 100.0) / total;
        }
    }
}


---

üß™ What this program does

üîπ Copies file twice in parallel
üîπ Shows:

NORMAL Progress: 34.12% | Speed: 112.45 MB/s
NIO Progress: 35.02% | Speed: 109.22 MB/s

üîπ Cancels both after 10 seconds
üîπ Uses CompletableFuture
üîπ Uses zero-copy style NIO buffers
üîπ Thread-safe cancel flag


---

‚ö†Ô∏è Important

Change paths:

Paths.get("D:/bigfile.bin")
Paths.get("E:/bigfile_normal.bin")
Paths.get("E:/bigfile_nio.bin")


---

üí° If you want, next upgrades:

I can give you:

‚úÖ Resume from breakpoint
‚úÖ SHA-256 checksum verification
‚úÖ Directory copy (recursive)
‚úÖ Spring Boot REST API version
‚úÖ Kafka-based streaming
‚úÖ Progress bar UI (Swing/JavaFX)

Just say which one: resume / checksum / directory / rest / kafka / ui