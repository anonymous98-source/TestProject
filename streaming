import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.*;
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

public class StreamingProgressReplace {

    static AtomicLong normalCopied = new AtomicLong(0);
    static AtomicLong nioCopied = new AtomicLong(0);
    static long totalSize;

    public static void main(String[] args) throws Exception {

        Path source = Paths.get("D:/bigfile.bin");
        totalSize = Files.size(source);

        ExecutorService executor = Executors.newFixedThreadPool(2);

        CompletableFuture<Void> f1 = CompletableFuture.runAsync(
                new CopyTask(source, Paths.get("E:/bigfile_normal.bin"), normalCopied),
                executor
        );

        CompletableFuture<Void> f2 = CompletableFuture.runAsync(
                new CopyTask(source, Paths.get("E:/bigfile_nio.bin"), nioCopied),
                executor
        );

        // Print two empty lines first
        System.out.println();
        System.out.println();

        Instant start = Instant.now();

        while (!f1.isDone() || !f2.isDone()) {
            printProgress("NORMAL", normalCopied.get(), start);
            printProgress("NIO   ", nioCopied.get(), start);

            // Move cursor up 2 lines
            System.out.print("\033[2A");

            Thread.sleep(1000);
        }

        // Final print without moving cursor up
        printProgress("NORMAL", normalCopied.get(), start);
        printProgress("NIO   ", nioCopied.get(), start);

        executor.shutdown();
        System.out.println("âœ… Done.");
    }

    static void printProgress(String name, long copied, Instant start) {
        double percent = (copied * 100.0) / totalSize;

        Duration elapsed = Duration.between(start, Instant.now());
        double seconds = Math.max(1, elapsed.toMillis() / 1000.0);

        double speed = (copied / 1024.0 / 1024.0) / seconds;

        // Clear line + print
        System.out.printf("\033[2K%s : %6.2f%% | %6.2f MB/s%n", name, percent, speed);
    }

    static class CopyTask implements Runnable {

        private final Path source;
        private final Path destination;
        private final AtomicLong progress;
        private static final int BUFFER_SIZE = 1024 * 1024;

        CopyTask(Path source, Path destination, AtomicLong progress) {
            this.source = source;
            this.destination = destination;
            this.progress = progress;
        }

        @Override
        public void run() {
            try (FileChannel in = FileChannel.open(source, StandardOpenOption.READ);
                 FileChannel out = FileChannel.open(destination,
                         StandardOpenOption.CREATE,
                         StandardOpenOption.WRITE,
                         StandardOpenOption.TRUNCATE_EXISTING)) {

                ByteBuffer buffer = ByteBuffer.allocateDirect(BUFFER_SIZE);
                int read;

                while ((read = in.read(buffer)) != -1) {
                    buffer.flip();
                    out.write(buffer);
                    buffer.clear();
                    progress.addAndGet(read);
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}