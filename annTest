public Optional<CommonReq> updateRequestStatus(
            ProcessRequestDto dto,
            String executorId
    ) throws JsonProcessingException {

        Long requestId = dto.getRequestId();
        log.info("Attempting to update status for request ID: {} by executor: {}", requestId, executorId);

        CommonReq request = commonRequestRepository.findById(requestId)
                .orElseThrow(() -> new ResourceNotFoundException("Request with ID " + requestId + " not found."));

        // SELF-APPROVAL CHECK
        if (executorId.equals(request.getCreatorId())) {
            log.warn("SECURITY VIOLATION: User {} attempted to approve their own request (ID: {}).", executorId,
                    requestId);
            throw new IllegalStateException("User cannot approve or reject their own request.");
        }

        if (request.getReqStatus() != RequestStatus.PENDING) {
            log.warn("Attempted to modify an already processed request. ID: {}, Current Status: {}", dto.getRequestId(),
                    request.getReqStatus());
            throw new IllegalStateException("Request has already been processed and cannot be modified.");
        }

        // --- UPDATE REQUEST STATE ---
        request.setExecutorId(executorId);
        request.setExecutorRemarks(dto.getRemarks());
        request.setExecutionDate(LocalDateTime.now());
        request.setReqStatus(dto.getStatus());

        // --- PROCESS BUSINESS LOGIC (STRATEGY) & PREPARE NOTIFICATION 1: TO MAKER (1-to-1) ---
        // This is a 1-to-1, so USER_ID is the recipient, TARGET_ROLE is null.
        if (RequestStatus.ACCEPTED.equals(dto.getStatus())) {
            log.info("Request {} ACCEPTED. Applying strategy for type {}", dto.getRequestId(), request.getReqType());
            // 1. Execute the business logic (e.g., save to master table)
            strategyFactory.getStrategy(request.getReqType()).processApproval(request);

            // Notify Maker: Approved
            notificationWriterService.createRequestApprovedNotification(request, executorId);
            request.setExecutionRemarks("Successfully processed approval.");

        } else {
            log.info("Request {} REJECTED.", dto.getRequestId());

            // Notify Maker: Rejected
            notificationWriterService.createRequestRejectedNotification(request, executorId, dto.getRemarks());
            request.setExecutionRemarks("Request rejected by user.");
        }

        // --- NOTIFICATION 2: CLOSURE (1-to-Many, Filtered) ---
        // We wrap this in Try/Catch because if this fails, we do NOT want to roll back the actual Approval.
        // The approval is critical data; the "FYI" notification to the group is secondary.
        try {
            // A. Get Group Config from Cache (Zero DB Cost)
            NotificationConfigDto config = permissionConfigService.getConfig(request.getReqType().name());

            // B. Prepare Message
            String action = dto.getStatus().equals(RequestStatus.ACCEPTED) ? "Approved" : "Rejected";
            String closureMessage = "CLOSURE: Request " + request.getTargetId() + " was " + action + " by " + executorId;

            // C. Send to Group (1-to-Many)
            // Pass the CHECKER'S ID as the exclusion ID.
            notificationWriterService.createNotification(
                    executorId,                 // User to EXCLUDE
                    config.getTargetRoles(),    // // Group to SEND TO -> The same roles that received the Pending alert excluding the executor
                    closureMessage,
                    config.getTargetUrl(),      // Link to history
                    request.getId().toString(),
                    "CommonRequestService"
            );
            log.info("Sent closure notification to group for Request ID: {}", requestId);

        } catch (Exception e) {
            // Log error but allow transaction to commit
            log.error("Failed to send closure notification for Request ID: {}", requestId, e);
        }

        // --- SAVE THE UPDATED REQUEST ---
        CommonReq updatedRequest = commonRequestRepository.save(request);

        return Optional.of(updatedRequest);
    }
