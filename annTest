package com.tcs.fincore.CommonMasterService.enums;

import com.fasterxml.jackson.annotation.JsonCreator;

public enum Operator {

    // ---------- STRING OPERATORS ----------
    CONTAINS,
    NOT_CONTAINS,
    STARTS_WITH,
    ENDS_WITH,

    // ---------- EQUALITY ----------
    EQUALS,
    NOT_EQUALS,

    // ---------- NULL CHECK ----------
    IS_NULL,
    IS_NOT_NULL,

    // ---------- COLLECTION ----------
    IN;

    /**
     * Used by Jackson while deserializing JSON.
     * Converts UI/operator strings to enum safely.
     */
    @JsonCreator
    public static Operator fromJson(String value) {
        return from(value);
    }

    /**
     * Centralized operator mapping.
     * UI labels â†’ backend enum.
     */
    public static Operator from(String value) {

        if (value == null || value.isBlank()) {
            throw new IllegalArgumentException("Operator cannot be null or empty");
        }

        return switch (value.toLowerCase()) {

            // ---------- STRING ----------
            case "contains" ->
                    CONTAINS;

            case "does not contain", "not_contains" ->
                    NOT_CONTAINS;

            case "starts with", "starts_with" ->
                    STARTS_WITH;

            case "ends with", "ends_with" ->
                    ENDS_WITH;

            // ---------- EQUALITY ----------
            case "is", "equals" ->
                    EQUALS;

            case "is not", "not equals", "not_equals" ->
                    NOT_EQUALS;

            // ---------- NULL ----------
            case "is empty", "is_null" ->
                    IS_NULL;

            case "is not empty", "is_not_null" ->
                    IS_NOT_NULL;

            // ---------- IN ----------
            case "is any of", "in" ->
                    IN;

            default ->
                    throw new IllegalArgumentException(
                            "Unsupported operator: " + value
                    );
        };
    }
} 






Operator op = filter.getOperator();

switch (op) {

    case CONTAINS ->
        predicates.add(cb.like(
            cb.lower(path.as(String.class)),
            "%" + value.toString().toLowerCase() + "%"
        ));

    case NOT_CONTAINS ->
        predicates.add(cb.notLike(
            cb.lower(path.as(String.class)),
            "%" + value.toString().toLowerCase() + "%"
        ));

    case STARTS_WITH ->
        predicates.add(cb.like(
            cb.lower(path.as(String.class)),
            value.toString().toLowerCase() + "%"
        ));

    case ENDS_WITH ->
        predicates.add(cb.like(
            cb.lower(path.as(String.class)),
            "%" + value.toString().toLowerCase()
        ));

    case EQUALS ->
        predicates.add(cb.equal(
            path, convert(type, value)
        ));

    case NOT_EQUALS ->
        predicates.add(cb.notEqual(
            path, convert(type, value)
        ));

    case IS_NULL ->
        predicates.add(cb.isNull(path));

    case IS_NOT_NULL ->
        predicates.add(cb.isNotNull(path));

    case IN -> {
        CriteriaBuilder.In<Object> in = cb.in(path);
        ((List<?>) value)
                .forEach(v -> in.value(convert(type, v)));
        predicates.add(in);
    }
}

