package com.ved.accessChecker;

import com.formdev.flatlaf.FlatDarkLaf;
import com.formdev.flatlaf.FlatLightLaf;
import com.formdev.flatlaf.FlatLaf;
import com.formdev.flatlaf.FlatClientProperties;
import com.formdev.flatlaf.intellijthemes.FlatDraculaIJTheme;
import com.formdev.flatlaf.util.SystemInfo;

import javax.swing.*;
import javax.swing.text.*;
import java.awt.*;
import java.io.FileWriter;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.List;
import java.util.prefs.Preferences;

public class AccessCheckerApp extends JFrame {

    /* ================= THEME SUPPORT ================= */

    private static final Preferences PREFS =
            Preferences.userNodeForPackage(AccessCheckerApp.class);

    private static final String PREF_THEME = "ui.theme";

    private enum Theme {
        SYSTEM, LIGHT, DARK, DRACULA
    }

    static {
        UIManager.put("TitlePane.useWindowDecorations", true);

        try {
            Theme theme = Theme.valueOf(
                    PREFS.get(PREF_THEME, Theme.SYSTEM.name())
            );

            switch (theme) {
                case LIGHT -> FlatLightLaf.setup();
                case DARK -> FlatDarkLaf.setup();
                case DRACULA -> FlatDraculaIJTheme.setup();
                case SYSTEM -> {
                    if (SystemInfo.isDarkMode())
                        FlatDarkLaf.setup();
                    else
                        FlatLightLaf.setup();
                }
            }
        } catch (Exception ignored) {}
    }

    /* ================= UI FIELDS ================= */

    private JTextArea inputArea;
    private JTextPane resultPane;
    private JProgressBar progressBar;
    private JTextField timeoutField;
    private JRadioButton hostBtn, tcpBtn;

    private final List<Result> results = new ArrayList<>();
    private IntelliJHeader header;

    /* ================= CONSTRUCTOR ================= */

    public AccessCheckerApp() {
        setTitle("Access Checker");
        setSize(960, 540);
        setResizable(false);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        setLocationRelativeTo(null);

        Image icon = Toolkit.getDefaultToolkit()
                .getImage(getClass().getResource("/icon.png"));
        setIconImage(icon);

        buildUI();
    }

    /* ================= MAIN UI ================= */

    private void buildUI() {
        JPanel root = new JPanel(new BorderLayout());
        setContentPane(root);

        header = new IntelliJHeader(getStripeColor());
        header.putClientProperty(
                FlatClientProperties.TITLE_BAR_DRAGGABLE, true
        );

        JLabel iconLabel = new JLabel(
                new ImageIcon(getClass().getResource("/icon.png"))
        );
        iconLabel.setBorder(BorderFactory.createEmptyBorder(0, 12, 0, 8));

        JLabel titleLabel = new JLabel("Access Checker");
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 13f));

        header.add(iconLabel, BorderLayout.WEST);
        header.add(titleLabel, BorderLayout.CENTER);

        root.add(header, BorderLayout.NORTH);

        JPanel panel = new JPanel(null);
        panel.setBackground(new Color(37, 37, 38));
        panel.setBorder(BorderFactory.createMatteBorder(
                1, 0, 0, 0, new Color(90, 90, 90)));

        root.add(panel, BorderLayout.CENTER);

        /* ---------- HEADER INFO ---------- */

        JLabel info = new JLabel(
                "<html><div style='text-align:right;'>Â© rugved.dev<br/>v1.0</div></html>");
        info.setBounds(800, 5, 150, 40);
        panel.add(info);

        JComboBox<Theme> themeBox = new JComboBox<>(Theme.values());
        themeBox.setSelectedItem(
                Theme.valueOf(PREFS.get(PREF_THEME, Theme.SYSTEM.name()))
        );
        themeBox.setBounds(660, 10, 130, 26);
        themeBox.addActionListener(e ->
                switchTheme((Theme) themeBox.getSelectedItem())
        );
        panel.add(themeBox);

        /* ---------- INPUT ---------- */

        JLabel inputLabel = new JLabel("Enter HOST or HOST:PORT");
        inputLabel.setBounds(30, 40, 300, 20);
        panel.add(inputLabel);

        inputArea = new JTextArea();
        JScrollPane inputScroll = new JScrollPane(inputArea);
        inputScroll.setBounds(30, 65, 380, 260);
        panel.add(inputScroll);

        JLabel resultLabel = new JLabel("Result");
        resultLabel.setBounds(460, 40, 200, 20);
        panel.add(resultLabel);

        resultPane = new JTextPane();
        resultPane.setEditable(false);
        JScrollPane resultScroll = new JScrollPane(resultPane);
        resultScroll.setBounds(460, 65, 450, 260);
        panel.add(resultScroll);

        hostBtn = new JRadioButton("Host Reachability (HTTP)", true);
        tcpBtn = new JRadioButton("TCP Port Check");

        ButtonGroup bg = new ButtonGroup();
        bg.add(hostBtn);
        bg.add(tcpBtn);

        hostBtn.setBounds(30, 340, 220, 25);
        tcpBtn.setBounds(260, 340, 160, 25);

        panel.add(hostBtn);
        panel.add(tcpBtn);

        JLabel timeoutLabel = new JLabel("Timeout (ms):");
        timeoutLabel.setBounds(460, 340, 100, 25);
        panel.add(timeoutLabel);

        timeoutField = new JTextField("3000");
        timeoutField.setBounds(560, 340, 80, 25);
        panel.add(timeoutField);

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 15, 0));
        buttonPanel.setBounds(0, 380, 960, 40);
        buttonPanel.setOpaque(false);

        JButton checkBtn = new JButton("Check");
        JButton exportBtn = new JButton("Export CSV");
        JButton copyBtn = new JButton("Copy Result");
        JButton resetBtn = new JButton("Reset");

        for (JButton b : new JButton[]{checkBtn, exportBtn, copyBtn, resetBtn}) {
            b.setPreferredSize(new Dimension(120, 32));
        }

        buttonPanel.add(checkBtn);
        buttonPanel.add(exportBtn);
        buttonPanel.add(copyBtn);
        buttonPanel.add(resetBtn);

        panel.add(buttonPanel);

        progressBar = new JProgressBar(0, 100);
        progressBar.setBounds(30, 430, 880, 22);
        progressBar.setStringPainted(true);
        progressBar.setString("Ready");
        panel.add(progressBar);

        checkBtn.addActionListener(e -> runChecks());
        exportBtn.addActionListener(e -> exportCSV());
        resetBtn.addActionListener(e -> resetAll());
        copyBtn.addActionListener(e ->
                Toolkit.getDefaultToolkit().getSystemClipboard()
                        .setContents(
                                new java.awt.datatransfer.StringSelection(
                                        resultPane.getText()), null));
    }

    /* ================= HEADER STRIPE ================= */

    private Color getStripeColor() {
        return switch (
                Theme.valueOf(PREFS.get(PREF_THEME, Theme.SYSTEM.name()))
        ) {
            case DRACULA -> new Color(80, 250, 123);
            case DARK -> new Color(0, 122, 204);
            case LIGHT -> new Color(24, 144, 255);
            default -> new Color(120, 120, 120);
        };
    }

    private static class IntelliJHeader extends JPanel {
        private Color stripe;

        IntelliJHeader(Color stripe) {
            this.stripe = stripe;
            setLayout(new BorderLayout());
            setPreferredSize(new Dimension(0, 36));
        }

        void setStripe(Color c) {
            stripe = c;
            repaint();
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            g.setColor(stripe);
            g.fillRect(0, 0, 6, getHeight());
        }
    }

    /* ================= THEME SWITCH ================= */

    private void switchTheme(Theme theme) {
        try {
            PREFS.put(PREF_THEME, theme.name());

            switch (theme) {
                case LIGHT -> FlatLightLaf.setup();
                case DARK -> FlatDarkLaf.setup();
                case DRACULA -> FlatDraculaIJTheme.setup();
                case SYSTEM -> {
                    if (SystemInfo.isDarkMode())
                        FlatDarkLaf.setup();
                    else
                        FlatLightLaf.setup();
                }
            }

            FlatLaf.updateUI();
            SwingUtilities.updateComponentTreeUI(this);
            header.setStripe(getStripeColor());

        } catch (Exception ignored) {}
    }

    /* ================= BUSINESS LOGIC (UNCHANGED) ================= */

    private void runChecks() {
        results.clear();
        resultPane.setText("");

        String[] lines = inputArea.getText().split("\\n");
        int timeout = Integer.parseInt(timeoutField.getText());

        progressBar.setIndeterminate(true);
        progressBar.setString("Checking...");

        SwingWorker<Void, Result> worker = new SwingWorker<>() {
            @Override
            protected Void doInBackground() throws MalformedURLException {
                for (String line : lines) {
                    if (line.isBlank()) continue;

                    Result r;
                    if (hostBtn.isSelected()) {
                        String host = line.trim().split(":")[0];
                        r = NetworkChecker.hostReachable(host, timeout);
                    } else {
                        String[] p = line.trim().split(":");
                        r = p.length == 2
                                ? NetworkChecker.tcp(p[0],
                                Integer.parseInt(p[1]), timeout)
                                : new Result(line, false, "INVALID FORMAT");
                    }
                    publish(r);
                }
                return null;
            }

            @Override
            protected void process(List<Result> chunks) {
                progressBar.setIndeterminate(false);
                for (Result r : chunks) {
                    results.add(r);
                    appendColored(r);
                }
            }

            @Override
            protected void done() {
                progressBar.setValue(100);
                progressBar.setString("Completed");
            }
        };

        worker.execute();
    }

    private void appendColored(Result r) {
        try {
            StyledDocument doc = resultPane.getStyledDocument();
            Style s = resultPane.addStyle("s", null);
            StyleConstants.setForeground(s,
                    r.success() ? new Color(0, 220, 140) : Color.RED);
            doc.insertString(doc.getLength(),
                    r.target() + " ? " + r.message() + "\n", s);
        } catch (Exception ignored) {}
    }

    private void exportCSV() {
        try (FileWriter fw = new FileWriter("access_result.csv")) {
            fw.write("Target,Status,Message\n");
            for (Result r : results) {
                fw.write(r.target() + "," +
                        (r.success() ? "SUCCESS" : "FAILED") + "," +
                        r.message() + "\n");
            }
            JOptionPane.showMessageDialog(this, "CSV exported");
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, e.getMessage());
        }
    }

    private void resetAll() {
        inputArea.setText("");
        resultPane.setText("");
        results.clear();
        progressBar.setValue(0);
        progressBar.setString("Ready");
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() ->
                new AccessCheckerApp().setVisible(true));
    }
}