package com.fincore.commonutilities.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

/**
 * Centralized Security Configuration Bean provider.
 * * Microservices should Import this class or define the beans similar to this
 * to ensure consistent CORS policies across the distributed system.
 */
@Configuration
public class CommonSecurityConfig {

    /**
     * Defines the CORS policy for the entire microservice ecosystem.
     * Since there is no Gateway, every service must handle CORS individually.
     * This bean standardizes that logic.
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        // 1. Allowed Origins
        // In PROD: Replace "*" with specific frontend domains (e.g., "https://myapp.com")
        configuration.setAllowedOrigins(List.of("https://localhost:1000", "https://localhost:4200", "https://fincoreuat.sbi","https://fincorest.sbi", "*"));

        // 2. Allowed Methods
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));

        // 3. Allowed Headers
        // "X-Request-Type" is critical for your RBAC Logic
        configuration.setAllowedHeaders(Arrays.asList(
                "Authorization",
                "Content-Type",
                "X-Request-Type",
                "X-Forwarded-For",
                "Accept"
        ));

        // 4. Expose Headers
        // Allows frontend to read the Auth header if updated
        configuration.setExposedHeaders(List.of("Authorization"));

        // 5. Allow Credentials
        // Set to true if using Cookies. If false, "*" origins are allowed.
        // If set to true, you CANNOT use "*" for origins.
        configuration.setAllowCredentials(false);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}






 */
@Component
@Slf4j
public class JwtUtil {

    // Default value provided for dev, override in application.properties
    @Value("${jwt.secret:bWV0aGlvbnlsdGhyZW9ueWx0aHJlb255bGdsdXRhbWlueWxhbGFueWw=}")
    private String secretKey;


    /**
     * Extracts the User ID (Subject) from the token.
     *
     * @param token The Bearer token.
     * @return The userId string.
     */
    public String getUserIdFromToken(String token) {
        String cleanToken = removeBearerPrefix(token);
        return extractClaim(cleanToken, Claims::getSubject);
    }

    /**
     * Extracts the Role ID from the token claims.
     *
     * @param token The Bearer token.
     * @return The Role ID as an integer.
     */
    public int getUserRoleFromToken(String token) {
        String cleanToken = removeBearerPrefix(token);
        return extractClaim(cleanToken, claims -> {
            Object role = claims.get("role");
            if (role instanceof Number) {
                return ((Number) role).intValue();
            }
            // Fallback for string roles if necessary
            if (role instanceof String) {
                try {
                    return Integer.parseInt((String) role);
                } catch (NumberFormatException ignored) {
                }
            }
            throw new IllegalArgumentException("Token role claim is not a number");
        });
    }

    /**
     * Validates the cryptographic signature and expiration of the token.
     *
     * @param token The Bearer token.
     * @return true if valid, false if expired or tampered.
     */
    public boolean isTokenValid(String token) {
        String cleanToken = removeBearerPrefix(token);
        return !isTokenExpired(cleanToken);
    }

    /**
     * GENERIC CLAIM EXTRACTOR (Made Public for Filter access).
     * This is required to extract 'jti' (JWT ID) for session validation.
     */
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    // --- Internal Helpers ---

    private String removeBearerPrefix(String token) {
        if (token != null && token.startsWith("Bearer ")) {
            return token.substring(7);
        }
        return token;
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    private SecretKey getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}


 @Bean
    @ConditionalOnMissingBean
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
        return new StringRedisTemplate(connectionFactory);
    }

