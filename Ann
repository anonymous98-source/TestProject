private List<ProcessDTO> getProcessData() {

    List<Map<String, Object>> processStatus = processStatusRepository.getData();

    List<Map<String, Object>> modifiableResults = processStatus.stream()
            .map(HashMap::new)
            .collect(Collectors.toList());

    // Group dynamically by PROCESS_TYPE
    Map<String, List<Map<String, Object>>> groupedByType =
            modifiableResults.stream()
                    .collect(Collectors.groupingBy(
                            m -> ((String)m.get("PROCESS_TYPE")).toUpperCase()
                    ));

    List<ProcessDTO> finalProcessedData = new ArrayList<>();

    for (Map.Entry<String, List<Map<String, Object>>> entry : groupedByType.entrySet()) {

        String type = entry.getKey();
        List<Map<String, Object>> items = entry.getValue();

        List<Map<String, Object>> stageDetails = new ArrayList<>();

        for (Map<String, Object> eachObj : items) {
            String stageId = String.valueOf(eachObj.get("PROCESS_STAGE"));

            eachObj.remove("id");
            eachObj.remove("processId");
            eachObj.remove("type");

            Optional<ProcessStages> existingStageData = processStagesRepository.findById(Long.parseLong(stageId));
            if (existingStageData.isPresent()) {
                ProcessStages stageData = existingStageData.get();

                StageDTO stageDTO = new StageDTO();
                stageDTO.setTitle(stageData.getTitle());
                stageDTO.setIcon(stageData.getIcon());

                eachObj.put("stage", stageDTO);

                stageDetails.add(eachObj);
            }
        }

        ProcessDTO dto = new ProcessDTO();
        dto.setType(type);
        dto.setStageDetails(stageDetails);

        finalProcessedData.add(dto);
    }

    return finalProcessedData;
}
