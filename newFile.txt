Nice, this class is already pretty clean. Let’s just “snap in” notifications in an optimal + consistent way.

I’ll:

Add two dependencies: permissionConfigService, notificationWriterService

Add a small helper createRoleRequestNotification(...)

Wire it into three methods:

createNewRoleRequest

acceptOrRejectRoleRequest

cancelRoleRequest


Make sure notification failures cause transaction rollback where it makes sense.



---

1️⃣ Add fields / dependencies at the top of the service

Inside RoleRequestServiceImpl (with the other @Autowired fields), add:

// You may need to adjust these import/class names as per your project
@Autowired
private PermissionConfigService permissionConfigService;

@Autowired
private NotificationWriterService notificationWriterService;

private static final String EVENT_SOURCE = "ROLE_REQUEST";

> If your PermissionConfigService or NotificationWriterService live in different packages, just fix the imports.




---

2️⃣ Update createNewRoleRequest – make it transactional + notify

Replace your current createNewRoleRequest method with this version:

@SuppressWarnings("unchecked")
@Transactional(rollbackFor = Exception.class)
public ResponseEntity<ResponseVO> createNewRoleRequest(final Map<String, Object> request, String userId) {
    final ResponseVO responseVo = new ResponseVO();
    final Map<String, Object> result = new HashMap<>();

    // 1) Basic request validation (return early)
    final String[] required = {"requestType", "requestPayload", "targetRoleId", "requestorUserId"};
    if (RequestUtility.verifyRequest(request, required)) { // 'true' means invalid
        result.put(STATUS, false);
        result.put(MESSAGE, "Invalid request.");
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
        responseVo.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseVo);
    }

    // 2) Parse payload safely
    final RoleRequest roleRequest;
    try {
        roleRequest = objectMapper.convertValue(request, RoleRequest.class);
    } catch (IllegalArgumentException ex) {
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
        responseVo.setMessage("Malformed request payload.");
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseVo);
    }

    // 3) Canonicalize inputs
    roleRequest.setRequestStatus(Constant.PENDING);
    roleRequest.setRequestDate(new Timestamp(System.currentTimeMillis()));
    roleRequest.setRequestorUserId(userId);

    final String requestFlag = String.valueOf(request.get("requestType"));
    final boolean isCreate = Constant.CREATE.equalsIgnoreCase(requestFlag);

    final int targetRoleId = roleRequest.getTargetRoleId();

    ObjectMapper mapper = new ObjectMapper();

    // Parse the JSON string
    JsonNode payloadNode = null;
    try {
        payloadNode = mapper.readTree(String.valueOf(request.get("requestPayload")));
    } catch (JsonProcessingException e) {
        log.error("Error parsing requestPayload", e);
        result.put(STATUS, false);
        result.put(MESSAGE, "Invalid requestPayload JSON");
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
        responseVo.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseVo);
    }

    // Extract simple fields
    String roleName = payloadNode.get("roleName").asText();
    String description = payloadNode.get("description").asText();

    log.info(roleName);

    final String requestorUserId = userId;
    final String requestPayload = roleRequest.getRequestPayload();

    log.info("Role request: flag={}, targetRoleId={}, roleName={}, requestorUserId={}",
            requestFlag, targetRoleId, roleName, requestorUserId);

    // 4) Fetch things once (avoid duplicate repository hits)
    final var existingRole = roleRepository.findRoleByRoleId(targetRoleId);
    final long pendingById = isCreate ? 0L : roleRequestRepository.countPendingRoleRequests(targetRoleId);
    final long pendingByName = isCreate && roleName != null
            ? roleRequestRepository.countPendingRoleRequestsByRoleName(roleName.toLowerCase())
            : 0L;

    // 5) Business rules (return early on failure)
    if (isCreate && existingRole != null) {
        log.info("Create denied: role with id {} already exists", targetRoleId);
        result.put(STATUS, false);
        result.put(MESSAGE, "A role with this ID already exists.");
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CONFLICT.value()));
        responseVo.setMessage(HttpStatus.CONFLICT.getReasonPhrase());
        return ResponseEntity.status(HttpStatus.CONFLICT).body(responseVo);
    }

    if (!isCreate && pendingById > 0) {
        result.put(STATUS, false);
        result.put(MESSAGE, "There is already a pending request for this role.");
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CONFLICT.value()));
        responseVo.setMessage(HttpStatus.CONFLICT.getReasonPhrase());
        return ResponseEntity.status(HttpStatus.CONFLICT).body(responseVo);
    }

    if (isCreate && pendingByName > 0) {
        result.put(STATUS, false);
        result.put(MESSAGE, "There is already a role creation request pending for this role.");
        responseVo.setResult(result);
        responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CONFLICT.value()));
        responseVo.setMessage(HttpStatus.CONFLICT.getReasonPhrase());
        return ResponseEntity.status(HttpStatus.CONFLICT).body(responseVo);
    }

    // 6) Finalize and persist
    if (isCreate) {
        roleRequest.setTargetRoleId(roleRequestRepository.getNewRoleIdOnCreation());
    }

    roleRequestRepository.save(roleRequest);

    result.put("roleRequest", roleRequest);
    result.put(STATUS, true);
    result.put(MESSAGE, "New request created.");
    responseVo.setResult(result);
    responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.CREATED.value()));
    responseVo.setMessage(HttpStatus.CREATED.getReasonPhrase());

    // 7) Notification: new ROLE request is now PENDING
    try {
        createRoleRequestNotification(
                roleRequest,
                "PENDING",                    // workflow stage
                true,                         // we are in success path
                "New role request created."   // info message
        );
    } catch (RuntimeException e) {
        // cause rollback (request + notification must be atomic)
        throw e;
    }

    return ResponseEntity.status(HttpStatus.CREATED).body(responseVo);
}


---

3️⃣ Update acceptOrRejectRoleRequest – notify on approve/reject

Here we hook notification after the DB operation is done by performUpdateOperation.

Replace your current method with:

@Transactional(rollbackFor = Exception.class)
public ResponseEntity acceptOrRejectRoleRequest(Map<String, Object> request, String userId) {
    ResponseVO<Map<String, Object>> responseVo = new ResponseVO<>();
    Map<String, Object> result = new HashMap<>();

    String actionFlag = (String) request.get("actionFlag");
    int requestId = Integer.parseInt((String) request.get("requestId"));
    RoleRequest roleRequest = roleRequestRepository.findRoleRequestByRequestId(requestId);

    roleRequest.setApproverUserId(userId);
    roleRequest.setApprovalDate(new Timestamp(System.currentTimeMillis()));
    String requestFlag = roleRequest.getRequestType();

    // Perform DB operations
    responseVo.setResult(performUpdateOperation(result, actionFlag, roleRequest, requestFlag));
    responseVo.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
    responseVo.setMessage(HttpStatus.OK.getReasonPhrase());

    // Notification (APPROVE / REJECT) – based on result
    boolean success = Boolean.TRUE.equals(result.get(STATUS));
    String infoMessage = (String) result.getOrDefault(MESSAGE, "No message");

    try {
        createRoleRequestNotification(
                roleRequest,
                actionFlag,   // ACCEPT / REJECT
                success,
                infoMessage
        );
    } catch (RuntimeException e) {
        // rollback everything (role update + request status) if notification fails
        throw e;
    }

    return new ResponseEntity<>(responseVo, responseVo.getStatusCode());
}

performUpdateOperation you can keep as-is.
It sets roleRequest status and saves it; we only use its result for notification.


---

4️⃣ Update cancelRoleRequest – notify on cancel

We only want notification when cancel succeeds, not when unauthorized.

Replace your current cancelRoleRequest with:

@Transactional(rollbackFor = Exception.class)
public ResponseEntity cancelRoleRequest(Map<String, Object> request, String userId) {
    ResponseVO responseVO = new ResponseVO();
    Map<String, Object> result = new HashMap<>();

    try {
        int requestId = Integer.parseInt(request.get("requestId").toString());
        RoleRequest roleRequest = roleRequestRepository.getRoleRequestByRequestId(requestId);

        log.info("Requester ID {}", roleRequest.getRequestorUserId());
        log.info("User ID : {}", userId);

        if (userId == null || userId.isEmpty() || !userId.equals(roleRequest.getRequestorUserId())) {
            result.put(STATUS, false);
            result.put(MESSAGE, "You are unauthorized to cancel this request");
            responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.UNAUTHORIZED.value()));
            responseVO.setMessage(HttpStatus.UNAUTHORIZED.getReasonPhrase());
        } else {
            roleRequest.setRequestStatus(Constant.CANCEL);
            roleRequestRepository.save(roleRequest);

            result.put(STATUS, true);
            result.put(MESSAGE, "Request cancelled");
            responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.OK.value()));
            responseVO.setMessage(HttpStatus.OK.getReasonPhrase());

            // Notification only on successful cancel
            try {
                createRoleRequestNotification(
                        roleRequest,
                        Constant.CANCEL,          // workflow action
                        true,
                        "Request cancelled by requester"
                );
            } catch (RuntimeException e) {
                // rollback cancel if notification fails
                throw e;
            }
        }

    } catch (Exception e) {
        log.error("Error while cancelling role request", e);
        result.put(STATUS, false);
        result.put(MESSAGE, e.getMessage());
        responseVO.setStatusCode(HttpStatusCode.valueOf(HttpStatus.BAD_REQUEST.value()));
        responseVO.setMessage(HttpStatus.BAD_REQUEST.getReasonPhrase());
    }
    responseVO.setResult(result);
    return new ResponseEntity(responseVO, responseVO.getStatusCode());
}


---

5️⃣ Shared helper for notifications (used by all 3 methods)

Add this helper near the bottom of the class:

private void createRoleRequestNotification(RoleRequest roleRequest,
                                           String actionFlag,   // PENDING / ACCEPT / REJECT / CANCEL
                                           boolean success,
                                           String infoMessage) {
    try {
        // Build requestTypeKey for notification configuration
        // Adjust mapping if your config keys are different
        String requestTypeKey = buildRoleRequestTypeKey(roleRequest);

        log.info("Fetching notification config for key: {}", requestTypeKey);
        NotificationConfigDto config = permissionConfigService.getConfig(requestTypeKey);

        // Derive status label to show in message
        String statusText;
        if ("PENDING".equalsIgnoreCase(actionFlag)) {
            statusText = success ? "PENDING" : "FAILED";
        } else if (Constant.ACCEPT.equalsIgnoreCase(actionFlag)) {
            statusText = success ? "APPROVED" : "FAILED";
        } else if (Constant.REJECT.equalsIgnoreCase(actionFlag)) {
            statusText = "REJECTED";
        } else if (Constant.CANCEL.equalsIgnoreCase(actionFlag)) {
            statusText = "CANCELLED";
        } else {
            statusText = "UNKNOWN";
        }

        String message = String.format(
                "[%s] Role request (requestId=%d, roleId=%d, type=%s) - %s",
                statusText,
                roleRequest.getRequestId(),
                roleRequest.getTargetRoleId(),
                roleRequest.getRequestType(),
                infoMessage
        );

        String referenceId = String.valueOf(roleRequest.getRequestId());

        notificationWriterService.createNotification(
                null,                    // userId == null => group notification
                config.getTargetRoles(), // e.g. "51,55"
                message,
                config.getTargetUrl(),   // e.g. "/role-requests"
                referenceId,
                EVENT_SOURCE
        );

    } catch (Exception e) {
        log.error("CRITICAL: Failed to create notification for role request {}. Rolling back transaction.",
                roleRequest.getRequestId(), e);
        throw new RuntimeException("Failed to create role request notification, rolling back.", e);
    }
}

private String buildRoleRequestTypeKey(RoleRequest roleRequest) {
    // Example: "ROLE_CREATE", "ROLE_MODIFY", ...
    // Adjust if your config keys are different
    return "ROLE_" + roleRequest.getRequestType().toUpperCase();
}


---

Summary

Atomic: in all three flows, if notification fails → RuntimeException → DB changes rollback (because of @Transactional).

Reusable: single helper for all role request notifications.

Config-based: target roles / URL resolved from permissionConfigService.getConfig(requestTypeKey).


If you share your actual NotificationConfigDto and PermissionConfigService signatures, I can micro-adjust the helper to be 100% plug-and-play with your codebase.